---
title: 'Clean React Study'
date: '2024-08-23 07:38:00'
description: Clean React관련 학습한 내용을 정리했습니다.
published: true
---

# ✅ State

## 1. 상태 소개

> 일단 상태부터 만들고 보는 초보에서 벗어나기

### 일단 상태가 무엇일까 ?

> 점점 어려워지는 상태관리가 문제일까? 상태를 대하는 태도가 문제일까?

**상태 종류(언제 만드는지 고민, 왜 만드는지 고민, 왜 필요한지 고민)**

- 컴포넌트 상태, 전역 상태, 서버 상태, 상태 관리(상태 변경, 상태 최적화, 렌더링 최적화, 불변성, 상태 관리자)

### 거꾸로 생각하기

> 우리는 상태관리를 왜 하고 있는 것일까?

- 상태 관리는 목적인가? 수단인가?
- 상태 관리를 위해 앱을 개발하는 것일까?
- 앱을 개발하는데 상태는 왜 관리하는 것일까?

### 일단 상태가 무엇인가?

- 상태 = State
- 사물, 현상이 놓여 있는 모양이나 형편
- ex) 무방비 상태, 정신 상태, 건강 상태, 이미 기차가 끊긴 상태

<br />
<br />

## 2. 올바른 초기값 설정

### 올바른 초기값 설정은 왜 중요할까?

- 렌더링 에러 처리 가능
- 초기값이 없을 경우, 해당 값을 통해서 계산하는 로직에서 에러 발생을 방지 할 수 있음

### 초기값

- 초기에 렌더링 되는 값
- 가장 먼저 렌더링 될 때, 순간적으로 보여질 수 있는 값

### 초기값 지키지 않을 경우

- 렌더링 이슈, 무한 루프, 타입 불일치로 의도하지 않는 동작 발생 ⇒ 런타임 에러 발생
- 초기값 넣지 않으면 `undefined` 값으로 셋팅 됨
- 상태를 CRUD ⇒ 상태를 **지울 때**도 초기값을 잘 기억해놔야 원상태로 돌아감.
- 빈값? `null` 처리 할 때 불필요한 방어코드도 줄여 줌

### 요약

**초기 상태를 올바르게 설정하자**

<br />
<br />

## 3. 업데이트 되지 않는 값

### 예시

```jsx
const NotUpdateValue = (): Element => {
   const INFO = {
	   name: 'My Component'
	   value: 'Clean Code React'
   };

   const [count, setCount] = useState(0);

   const onIncrement = () => setCount((prevCount) => prevCount + 1);
   const onDecrement = () => setCount((prevCount) => prevCount - 1);

   return (
	   <div className="App">
		   <main className="App-main">
			   <header>{INFO}</header>
			   <ShowCount info={INFO} count={count} />
			   <ButtonGroup onDecrement={onDecrement} onIncrement={onIncrement} />
		   </main>
	   </div>
   )
}
```

`INFO` 상수가 컴포넌트 안에 존재했을 때의 문제점

- 상수를 다루거나 아니면 일반적인 방치
- 컴포넌트가 렌더링 될 때마다 해당 객체가 새로 새성성되고 참조됨
- 업데이트가 되지 않는 일반적인 객체
- 리액트 상태로 바꾼다던가 혹은 아예 외부로 내보내야 함.

<br />
<br />

## 4. 불필요한 상태 제거하기

### 결론

```tsx
// 기존
const [userList, setUserList] = useState(MOCK_DATA);
const [complUserList, setComplUserList] = useState(MOCK_DATA);

useEffect(() => {
	const newList = complUserList.filter((user) => user.completed === true);

	setUserList(newList);
}, [userList);

// 변경
const complUserList = complUserList.filter((user) => user.completed === true);
```

###  내용

불필요한 상태를 만든다면?

- 결국에는 리액트에 의해 관리되는 값이 늘어나는 것
- 그러다보면 렌더링에 양향을 주는 값이 늘어나서 관리 포인트가 더더욱 늘어 남

컴포넌트 내부에서의 변수는?

- 렌더링 마다 고유의 값을 가지는 계산된 값

### 요약

1. **props를 useState에 넣지 않고** 바로 return 문에 사용하기
2. 컴포넌트 내부 변수는 **렌더링마다 고유한 값을 가짐**
3. 따라서 useState가 아닐, const로 상태를 선언하는게 좋은 경우도 있음

<br />
<br />

## 5. useState 대신 useRef

### 결론

```tsx
// 기존
export const component = () => {
  ❌
	const [isMount, setIsMount] = useState(false);

	useEffect(() => {
		if(!isMount) {
			setIsMount(true);
		}
	}, [isMount]);
};

// 변경
export const component = () => {
  💡
	const isMount = useRef(false);

	useEffect(() => {
		isMount.current = true;

		return () => (isMOunt.current = false);
	}, [isMount]);
};
```

### 내용

### 리렌더링 방지가 필요하다면 `useState` 대신 `useRef`

**useRef이란**

- 가변 컨테이너
- 한번 고정된 값을 컴포넌트 내부에서 사용할 경우 `useState`로 사용할 필요가 없음(컴포넌트의 전체적인 수명과 동일하게 지속된 정보를 일관적으로 제공해야 하는 경우)
- 꼭 DOM을 직접 조작할 때만 `useRef`를 사용하는 것이 아님

### 요약

- `useState` 대신 `useRef` 를 사용하면 컴포넌트의 생명주기와 동일한 리렌더링되지 않는 상태를 만들 수 있다.

<br />
<br />

## 6. 연관된 상태 단순화하기

### 결론

```tsx
// 기존
const [isLoading, setIsLoading] = useState(false);
const [isFinish, setIsFinish] = useState(false);

// 변경
const PROMISE_STATE = {
	INIT: 'init',
	LOADING; 'loading',
	FINISH: 'finish'
};

const [promiseState, setPromiseState] = useState(PROMISE_STATE);
```

### 내용

- React 는 개발하는데 있어 자유로움
- 여러 연관된 state를 만들어서 관리하는게 아니라, 하나의 불변의 값으로 관리

  ```tsx
  const PROMISE_STATE = {
  	INIT: 'init',
  	LOADING; 'loading',
  	FINISH: 'finish'
  	ERROR: 'error'
  };

  const FlatState = () => {
  	const [promiseState, setPromiseState] = useState(PROMISE_STATE);

  	const fetchData = () => {
  		// fetch Data 시도
  		setPromiseState(PROMISE_STATE.LOADING);

  		fetch(url)
  		.then(() => {
  			// fetch Data 성공
  			setPromiseState(PROMISE_STATE.FINISH);
  		})
  		.catch(() => {
  			// fetch Data 실패
  			setPromiseState(PROMISE_STATE.ERROR);
  		})
  	}

  	if (promiseState === PROMISE_STATE.LOADING) return <LoadingComponent />
  	if (promiseState === PROMISE_STATE.FINISH) return <FinishComponent />
  	if (promiseState === PROMISE_STATE.ERROR) return <ErrorComponent />
  }
  ```

### 요약

- 리액트의 상태를 만들 때 `연관된 것들끼리 묶어서 처리`하면 에러를 방지하고 코드가 간결해진다.

<br />
<br />

##  7. useState -> useReducer로 리팩토링

###  결론

```tsx
// 기존
const [isLoading, setIsLoading] = useState(false);
const [isFinish, setIsFinish] = useState(false);

// 변경
const [state, dispatch] = useReducer(reducer, INIT_STATE);
```

### 내용

- 구조화된 상태를 원한다면 `useReducer()`

```tsx
const INIT_STATE = {
  isLoading: false,
  isSuccess: false,
  isFail: false,
};

// 오타 방지 및 타입 정확성
const ACTION_TYPE = {
  FETCH_LOADING: 'FETCH_LOADING',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_FAIL: 'FETCH_FAIL',
};

// 다른 곳에서도 사용 가능
// 순수 JS로 Third Party library 없이 상태를 관리 가능
// 그 상태를 조금 더 체계적으로 구조화 가능
const reducer = (state, action) => {
  // 보통 type을 쓰지만 action 객체의 형태는 자유
  switch (action.type) {
    case 'FETCH_LOADING':
      return { isLoading: true, isSuccess: false, isFail: false };

    case 'FETCH_SUCCESS':
      return { isLoading: false, isSuccess: true, isFail: false };

    case 'FETCH_FAIL':
      return { isLoading: false, isSuccess: false, isFail: true };

    default:
      return INIT_STATE;
  }
};

const StateToReducer = () => {
  const [state, dispatch] = useReducer(reducer, INIT_STATE);

  const fetchData = () => {
    // fetch Data 시도
    // - 추상화
    dispatch({ type: ACTION_TYPE.FETCH_LOADING });

    fetch(url)
      .then(() => {
        // fetch Data 성공
        dispatch({ type: ACTION_TYPE.FETCH_SUCCESS });
      })
      .catch(() => {
        // fetch Data 실패
        dispatch({ type: ACTION_TYPE.FETCH_FAIL });
      });
  };

  if (state.isLoading === PROMISE_STATE.LOADING) return <LoadingComponent />;
  if (state.isSuccess === PROMISE_STATE.FNISH) return <FinishComponent />;
  if (state.isFail === PROMISE_STATE.ERROR) return <ErrorComponent />;
};
```

### 요약

- 여러 상태가 연관됐을 때, useState 대신, `useReducer를 사용하면 상태를 구조화` 할 수 있음

<br />
<br />

## 8. 상태 로직 Custom Hooks로 뽑아내기

### 결론

```tsx
// 기존
const [state, setState] = useState();

useEffect(() => {
  const fetchData = () => {
    setState(state);
  };

  fetchDate();
}, []);

if (state.isLoading) return <LoadingComponent />;
if (state.isFail) return <FailComponent />;

// 변경
const { isLoading, isFail } = useFetchData();

if (state.isLoading) return <LoadingComponent />;
if (state.isFail) return <FailComponent />;
```

### 내용

- 로직만 뺌

```tsx
const INIT_STATE = {
	isLoading: false,
	isSuccess: false,
	isFail: false,
};

// 오타 방지 및 타입 정확성
const ACTION_TYPE = {
	FETCH_LOADING: 'FETCH_LOADING',
	FETCH_SUCCESS: 'FETCH_SUCCESS',
	FETCH_FAIL: 'FETCH_FAIL',
}

// 다른 곳에서도 사용 가능
// 순수 JS로 Third Party library 없이 상태를 관리 가능
// 그 상태를 조금 더 체계적으로 구조화 가능
const reducer = (state, action) => {
	// 보통 type을 쓰지만 action 객체의 형태는 자유
	switch (action.type) {
		case 'FETCH_LOADING':
			return { isLoading: true, isSuccess: false, isFail: false }

		case 'FETCH_SUCCESS':
			return { isLoading: false, isSuccess: true, isFail: false }

		case 'FETCH_FAIL':
			return { isLoading: false, isSuccess: false, isFail: true }

		default:
			return INIT_STATE;
	}
};

const useFetchData = (url) => {
	const [state, dispatch] = useReducer(reducer, INIT_STATE);

	useEffect(() => {
		const fetchData = async () => {
		// fetch Data 시도
		// - 추상화
		dispatch({ type: ACTION_TYPE.FETCH_LOADING });

		await fetch(url)
		.then(() => {
			// fetch Data 성공
			dispatch({ type: ACTION_TYPE.FETCH_SUCCESS });
		})
		.catch(() => {
			// fetch Data 실패
			dispatch({ type: ACTION_TYPE.FETCH_FAIL });
			})
		}
	}, [url)

	return state
}

const  CustomHooks= () => {
	const { isLoading, isFail, isSuccess } = useFetchData('url);

	if (state.isLoading === PROMISE_STATE.LOADING) return <LoadingComponent />
	if (state.isSuccess === PROMISE_STATE.FNISH) return <FinishComponent />
	if (state.isFail === PROMISE_STATE.ERROR) return <ErrorComponent />
}
```

### 요약

- `Custom Hooks를 사용하면` 코드를 확장성 있고 재사용 가능하게 작성할 수 있다.

<br />
<br />

## 9. 이전 상태 활용하기

### 결론

```tsx
setAge(age + 1);

setAge((prevAge) => prevAge + 1);
```

### 내용

- 타이밍을 확실히 하기 위해서 이전 상태 값을 가지고 업데이트 진행(update function)

```tsx
const PrevState = () => {
  const [age, setAge] = useState(0);

  const updateState = () => {
    setAge((prevAge) => prevAge + 1);
  };
};
```

### 요약

- **updater function을 사용해 prev state를 고려**하면 예상치 못한 결과를 예방할 수 있다.

<br />
<br />

# ✅ Props

## 1. 불필요한 PROPS 복사 및 연산

### 🌈 결론

```tsx
// 변경 전
function component({ value }) {
  const [copyValue] = useState(무거운_연산(value));

  return <div>{copyValue}</div>;
}

// 변경 후
function component({ value }) {
  const [copyValue] = useMemo(() => 무거운_연산(value), [value]);

  return <div>{copyValue}</div>;
}
```

### ✍️ 내용

- `props`로 전달 받은 값을 `useState`에서 셋팅하는 것이 아닌, 바로 사용하는 것이 좋음
- 아래와 같이 `props`로 전달 받은 값을 가지고 무거운 연산을 진행하면, 렌더링할 때마다 해당 컴포넌트가 호출되어서 연산을 지속적으로 하기 때문에 비효율적임 → 그래서 애초에 `props`로 전달하기 전에 이미 무거운 연산을 한 결과 값을 `props`로 전달을 해야 함, 아니면 `useMemo`를 사용

  ```tsx
  function CopyProps({ value }) {
    const copyValue = 값_비싸고_무거운_연산(value);
    const [copyValue] = useMemo(() => 무거운_연산(value), [value]);

    return <div>{copyValue}</div>;
  }
  ```

### ⭐️ 요약

불필요한 연산을 줄이는 방법

- `Props` 바로 사용하기(`useState` 담기 X, 무거운 연산의 `props`로 사용 X)
- 연산된 값을 `Props`로 넘기기
- `useMemo`로 연산 최적화하기

<br />
<br />

## 2. Curly Braces

### 🌈 결론

- 중괄호(Curly Braces) 사용법

```tsx
<Image
  alt='image'
  src='image.jpg'
  style={{ width: 100 }}
  className='clean-dev'
/>
```

### ✍️ 내용

1.  Curly Brace 사용 O

    - 값이 계산되는 경우(논리적인 숫자, Boolean, 객체, 배열, 함수 표현식)
    - 객체를 넣어야 하는 경우

2.  Curly Brace 사용 X

    - 문자열일 경우

           ```tsx
           <Image
             alt={'image'}
             src={'image.jpg'}
             style={{ width: 100 }}
             className='clean-dev'
           />
           ```

### ⭐️ 요약

- String일 경우 Curly Brace 사용하지 않기

<br />
<br />

## 3. Props 축약하기

### 🌈 결론

```tsx
// 변경 전
function component(props) {
  <HeaderComponent hasPadding={props.hasPadding}>
    <ChildComponent isDarkMode={props.isDarkMode} isLogin={props.isLogin} />
  </HeaderComponent>;
}

// 변경 후
function component({ hasPadding, ...props }) {
  <HeaderComponent hasPadding>
    <ChildComponent {...props} />
  </HeaderComponent>;
}
```

### ✍️ 내용

**ShortHand Props는언제 사용할까?**

- 토글링 값을 Props로 전달 할 때

```tsx
function component({ hasPadding, ...props }) {
	<HeaderComponent hasPadding>
		<ChildComponent {...props} />
	</HeaderComponent>
```

### ⭐️ 요약

- ShortHand Props로 Props를 축약할 수 있다.

<br />
<br />

## 4. Single Quotes vs Double Quotes

### 🌈 결론

```tsx
// ✅
<a href="https://www.naver.com">Naver</a>

// ❌
<input class='ccrc' type="button" value='Clean' />

// ❌
<Clean style={{ backgroundPosition: "left" }} />
```

### ✍️ 내용

- 팀에서 일반적인 규칙 ⇒ 일관성을 지키기 위함
- HTML과 JS 환경에서 사용하는 부분 구분
  - HTML은 Double Quotes 주로 사용(HTML Attribute를 위한 값)
  - JS은 Single Quotes 주로 사용(객체의 값) cf) JSX는 Single Quotes
- 결론적으로 규칙을 정하고 그 맥락을 파악하고 공유하자 ⇒ Lint, 포맷팅 도구(Prettier)에 위임하자

### ⭐️ 요약

- **HTML, JS를 구분해서** Single Quotes와 Double Quotes를 결정하자
- 규칙은 팀끼리 정해서 자동 포맷팅 시키자

<br />

## 5. Props 네이밍

### 🌈 결론

```tsx
// ❌
<ChildComponent
	class="mt-0"
	Clean="code"
	clean_code="react"
	otherComponent={OtherComponent}
	isShow={true}
/>

// ✅
<ChildComponent
	className="mt-0"
	clean="code"
	cleanCode="react"
	OtherComponent={OtherComponent}
	isShow
/>
```

### ✍️ 내용

- React Component는 파스칼로 한다.

### ⭐️ 요약

- class는 `className`으로 사용하기
- `camel case` 사용하기
- 무조건 true라면 `isShow={true}`가 아닌, `isShow`로 축약하기
- 컴포넌트라면 대문자로 시작하기

<br />

## 6. 인라인 스타일 주의 하기

### 🌈 결론

```tsx
// ❌
function InlineStyle(): Element {
  return (
    <button style="background-color: 'red'; font-size: '14px';">
      Clean Code
    </button>
  );
}

// ✅
function InlineStyle(): Element {
  const myStyle = { backgroundColor: 'red', fontSize: '14px' };

  return <button style={myStyle}>Clean Code</button>;
}
```

### ✍️ 내용

- JS로 HTML을 표현하는 문법이 바로 JSX임
- 고정된 스타일 객체 값이라면, 컴포넌트 외부로 빼는 것이 좋음(매번 랜더링 될 때마다 계속 평가되기 때문)

  ```tsx
  const myStyle = { backgroundColor: 'red', fontSize: '14px' };

  function InlineStyle(): Element {
    return <button style={myStyle}>Clean Code</button>;
  }
  ```

### ⭐️ 요약

- JSX에서 인라인 스타일을 쓰려면 중괄호 안에 `camelCase key`를 가진 객체를 넣어야 한다.

<br />
<br />

## 7. CSS-in-JS 인라인 스타일 지양하기

### 🌈 결론

```tsx
// ❌
function InlineStyle(): Element {
	return (
		<button css={
			css`
				background-color: white;
				border: 1px solid #eee;
				border-radius: 0.5rem;
				padding: 1rem;
			`}
		}>
			Clean Code
		</button>
	);
}

// ✅
function InlineStyle(): Element {
	return (
		<button css={cardCss.self}>Clean Code</button>
	);
}
```

### ✍️ 내용

- css 백틱으로 진행했을 때에는 VSCode 자동완성과 DX 측면에서 좋지 않기 때문에 JS 스타일을 주는 것이 좋음
- 아래와 같이 스타일을 외부 뺐을 때의 장점
  - 외부로 분리했기 때문에 스타일이 렌더링 될 때마다 직렬화 되지 않는다. → 한번만 된다.
  - 동적인 스타일을 실수로 건드는 확률이 적어진다.
  - 스타일 관련 코드를 분리해서 로직에 집중하고 JSX를 볼 때 조금 더 간결하게 볼 수 있다.

```tsx
// 장점
// - 타입 안정성
// - 자동 완성으로 생산성 DX 향상
// - export 할 경우, 외부 컴포넌트에서 사용 가능
const cardCSS = {
  self: css({
    backgroundColor: 'white',
    border: '1px solid #eee',
    borderRadius: '0.5rem',
    padding: '1rem',
  }),
  title: css({
    fontSize: '1.25rem',
  }),
};

// CSS IN JS 인라인 스타일 지양하기
// - 성능에 민감함
export function Card({ title, children }) {
  return (
    <div css={cardCss.self}>
      <h5 css={cardCss.title}>{title}</h5>
      {children}
    </div>
  );
}
```

### ⭐️ 요약

- CSS in JS 인라인 스타일을 지양해야 하는 이유 - `성능 저하 발생 유발`, `휴먼 에러가 발생 가능성 존재`, `export 할 수 없음`

<br />
<br />

## 8. 객체 Props 지양하기

### ✍️ 내용

- 변하지 않는 값일 경우 컴포넌트 외부로 드러내기
- 필요한 값만 객체를 분해해서 Props로 내려 준다.
- 정말 값 비싼 연산, 너무 잦은 연산이 있을 경우 useMemo() 활용하여 계산된 값을 메모이제이션 한다.
- Props 값을 나누어서 다른 컴포넌트에 Props를 전달한다.

  ```tsx
  // ❌
  function SomeComponent() {
    return (
      <ChildComponent
        propObj={{ hello: 'world' }}
        propArr={['hello', 'hello']}
      />
    );
  }

  // ✅ 방법 1
  function SomeComponent() {
    const [propArr, setPropArr] = useState(['hello', 'hello']);

    return <ChildComponent hello1='world' hello2={propArr.at(0)} />;
  }

  // ✅ 방법 2
  function SomeComponent({ heavyState }) {
    const [propArr, setPropArr] = useState(['hello', 'hello']);

    const computedState = useMemo(
      () => ({
        heavyState: heavyState,
      }),
      [heavyState]
    );

    return (
      <ChildComponent
        hello1='world'
        hello2={propArr.at(0)}
        computedState={computedState}
      />
    );
  }
  ```

**React 리렌더링 되는 여부 판별**

- React에서 `Object.is`는 컴포넌트의 props나 state가 변경되었는지 판단하는 데 사용됩니다. 이 함수는 두 값이 동일한 메모리 주소를 참조하는지를 확인합니다.

1. 리렌더링과 `Object.is`
   - React는 props나 state의 변경 여부를 `Object.is`로 판단합니다.
   - 객체나 배열은 참조 타입이므로, 새로 생성된 객체나 배열은 이전과 다른 것으로 간주됩니다(비록 내용이 같아도).
2. ❌ 컴포넌트의 문제점
   - `{ hello: 'world' `}와 `['hello', 'hello']`는 컴포넌트가 렌더링될 때마다 새로 생성됩니다.
   - React는 이 새로 생성된 값들이 이전 값과 다르다고 판단하여 ChildComponent를 리렌더링합니다.
3. ✅ 방법 1 코드의 최적화
   - 상태로 관리된 propArr는 렌더링 간에 동일한 참조를 유지합니다.
   - React는 `Object.is`를 통해 props가 변하지 않았음을 인식하고, 컴포넌트의 불필요한 리렌더링을 방지합니다.

<br />

## 9. HTML Attribute 주의하기

### 🌈 결론

```tsx
// ❌
function MyButton({ children, type }) {
  return <button type={type}>{children}</button>;
}

// ✅
function MyButton({ children, ...rest }) {
  return <button {...rest}>{children}</button>;
}
```

### ✍️ 내용

1. HTML 기본 속성 주의하기

   - HTML와 JSX에서 사용하는 예약어 주의
   - HTML 표준어 찾아서 주의(내가 만든 Component의 Props와 겹치지는지 확인)

   ```tsx
   function HTMLDefaultAttribute() {
     const MyButton = ({ children, ...rest }) => (
       <button {...rest}>{children}</button>
     );

     return (
       <>
         <MyButton className='mt-0' type='submit'>
           Clean Code
         </MyButton>

         <MyButton type='number' maxLength='99'>
           Clean Code
         </MyButton>
       </>
     );
   }
   ```

### ⭐️ 요약

- HTML, JS에서 정의한 예약어와 커스텀 컴포넌트 Props가 혼용되지 않도록 주의

<br />

## 10. Spread 연산자 쓸 때 주의할 점

### 🌈 결론

```tsx
// ❌
const ParentComponent = (props) => {
  return <childOrHOCComponent {...props} />;
};

// ✅
const ParentComponent = (props) => {
  const { 관련_없는_props, 관련_있는_props, ...나머지_props } = props;

  return (
    <childOrHOCComponent 관련_있는_props={관련_있는_props} {...나머지_props} />
  );
};
```

### ✍️ 내용

- 코드를 예측하기 어렵다.

### ⭐️ 요약

- props에서 spread 연산자가 쓰이면, 관련 있는 props, 없는 props, 나머지 props로 나눠보자

<br />

## 11. 많은 Props 분리하기

### 🌈 결론

```tsx
// ❌
<JoinForm
  user={user}
  auth={auth}
  location={location}
  favorite={favorite}
  handleSubmit={handleSubmit}
  handleReset={handleReset}
  handleCancel={handleCancel}
/>

// ✅
<JoinForm
  handleSubmit={handleSubmit}
  handleReset={handleReset}
  handleCancel={handleCancel}
>
  <CheckBoxForm formData={user} />
  <CheckBoxForm formData={auth} />
  <RadioButtonForm formData={location} />
  <SectionForm formData={favorite} />
</JoinForm>
```

### ✍️ 내용

### 너무 많은 Props를 넘기는 경우

- 결과보다는 일단 실행 → 분리의 대상?
- TanStack Query, Form Library, 상태 관리자, Context API, Composition

### 리팩토링 과정

1. One Depth 분리를 한다.
2. 확장성을 위한 분리를 위해 도메인 로직을 다른 곳으로 모아넣는다.
3. 꼭 라이브러리를 먼저 도입하는게 아니라, 먼저 분리 후 생각한다.

### ⭐️ 요약

- props가 많다면 컴포넌트를 분리해보자.

<br />

## 12. 단순하게 Props 내리기

### 🌈 결론

```tsx
// ❌
const UserInfo = ({ user }) => {
  return (
    <div>
      <img src={user.avatarImgUrl} />
      <h3>{user.userName}</h3>
      <h4>{user.email}</h4>
    </div>
  );
};

// ✅
const UserInfo = ({ avatarImgUrl, userName, email }) => {
  return (
    <div>
      <img src={avatarImgUrl} />
      <h3>{userName}</h3>
      <h4>{email}</h4>
    </div>
  );
};
```

### ✍️ 내용

1. ❌ 객체를 Props로 그대로 전달하는 경우

- UserInfo 렌더링될 때마다 user 객체가 새로 생성됨. React는 이 새로운 user 객체를 보고 UserInfo 컴포넌트에 전달된 props가 변경되었다고 인식하여 UserInfo를 리렌더링함

2. ✅ 객체를 분리하여 전달하는 경우

- 문자열이나 숫자와 같은 기본형 데이터는 참조값이 아닌 실제 값을 비교하기 때문에, 값이 변하지 않는 한 UserInfo는 리렌더링되지 않음
- 참고) 객체나 배열 같은 참조형 데이터는 메모리 주소(참조값)가 변경되면 React가 새로운 데이터로 인식함. 따라서 객체가 새로 생성될 때마다 자식 컴포넌트는 리렌더링될 가능성이 큼

### ⭐️ 요약

- props에 객체 전체를 내리지 말고 꼭 필요한 값만 내리자

<br />

# ✅ Component

## 1. Components 정의

### 🌈 결론

- 컴포넌트가 무엇인지 정확하게 인지하고 사용해야 함

### ✍️ 내용

**Component 사전적 의미**: 구성하는, 구성하고 있는, 성분의 구성 요소, 성분

**공식 문서에서 Component 의미**

1. 과거 컴포넌트 의미
   - 스스로 상태를 관리하는 캡슐화된 컴포넌트
   - 컴포넌트를 조합해 복잡한 UI 개발 가능
   - 컴포넌트 로직은 템플릿이 아닌 JS로 작성
   - 이로 인해 다양한 형식의 데이터를 앱 안에서 손쉽게 전달할 수 있고, DOM과 별개로 상태를 관리 가능
2. 현재 컴포넌트 의미
   - 기존에는 웹 페이지를 만들 때 웹 개발자가 컨텐츠를 마크업한 다음 JS를 뿌려서 상호작용을 추가하는 방향이었으며, 이는 웹에서 상호작용이 중요했던 시절에 효과이었음
   - 이제는 많은 사이트와 모든 앱에서 상호작용을 기대하고 React는 동일한 기술을 사용하면서도 상호작용을 우선시 하며, React 컴포넌트는 마크업으로 뿌릴 수 있는 JS 함수 역할을 함
   - [참고](https://react.dev/learn/thinking-in-react)

### ⭐️ 요약

**Component 역할**

- 많은 사이트와 모든 앱에서 상호작용을 기대함
- React는 동일한 기술을 사용하면서도 상호작용을 우선시함
- React 컴포넌트는 마크업으로 뿌릴 수 있는 JS 함수 임

<br />
<br />

## 2. Self Closing Tags

### 🌈 결론

- `Self Closing Tags`를 정확히 인지하고 사용하자

### ✍️ 내용

1. `Self Closing Tags` 의미

   - 명시적으로 닫는 태그가 필요가 없음
   - **기본 HTML 요소인지 아닌지 명확한 차이를 가져야 함**

     ```tsx
     function HelloWorld() {
       return (
         <Clean>
           <Code>
             <img />
             <br />
           </Code>
         </Clean>
       );
     }
     ```

   - `Vue`에서는 HTML에서 사용되어지는 `header`와 같은 태그 사용이 불가함 대신에 `app-header` 이런식으로 사용해야 함
   - [참고](https://developer.mozilla.org/en-US/docs/Glossary/Void_element)

### ⭐️ 요약

- `Self Closing Tags`를 정확히 인지하고 사용하자

<br />
<br />

## 3. Fragment 지향하기

### 🌈 결론

- `Fragment`가 무엇인지 알고 쓰자.

### ✍️ 내용

- React v16.2 출시
  - `Fragment` 런타임시 Fragment는 사라짐
  - Babel 버젼에 따라서 Fragment Short Cut 사용 여부도 확인해야 됨
  - index를 주입할 때, Short Cut이 아닌 `Fragment` 컴포넌트 사용해야 함
    ```tsx
    function Example() {
      return (
        <>
          <Child />
        </>
      );
    }
    ```
- [참고](https://velog.io/@yeonsubaek/React-JSX-%EB%AC%B8%EB%B2%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%97%AC%EB%9F%AC-%EC%9A%94%EC%86%8C%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%8C-%ED%95%98%EB%82%98%EB%A1%9C-%EA%B0%90%EC%8B%B8%EB%8A%94-%EC%9D%B4%EC%9C%A0)

### ⭐️ 요약

- `Fragment`가 필요한 경우에만 사용하자.

<br />
<br />

## 4. Fragment 지양하기

### 🌈 결론

- 상황에 따라 불필요한 Fragment를 줄이자.

### ✍️ 내용

- 불필요한 Fragment 사용을 줄이자.

```tsx
// 불필요한 계층 줄이기
function Example() {
  return (
    <>
      <div>
        <div></div>
      </div>
    </>
  );
}
```

```tsx
function StringRender() {
  // return <>'Clean Code'</> ❌
  return 'Clean Code';
}
```

```tsx
// 렌더링 될 필요 없는 JSX 줄이기
function ConditionalRenderingEX() {
	return(
		<div>
			<h1>{isLoggedIn ? 'User' : <></>}</h1>
			<h1>{isLoggedIn ? 'User' : null}</h1>
			<h1>{isLoggedIn && 'User'}</h1>
			{isLoggedIn && <h1>User</h1>
		</dvi>
	)
}
```

### ⭐️ 요약

- 불필요한 Fragment 사용을 줄이자.

<br />
<br />

## 5. 알아두면 좋은 컴포넌트 네이밍

### 🌈 결론

```tsx
function ComponentNaming() {
	return (
		<>
			<h1></h1> // 🤔 lowercase
			<h2></h2>
			<div></div>
			<input />
			<MyuComponent></MyComponent>  // 🤔 pascal case
			<my-component></my-component> // 🤔 kebab case
		</>
	)
}
```

### ✍️ 내용

### 컴포넌트 네이밍

- 일반적으로 컴포넌트 `PascalCase`
- 기본 HTML 요소는 `lower case`
- route based file name
  - `component-naming.jsx` ⇒ `<ComponentNaming />`
  - `component-naming/index.jsx` ⇒ `<ComponentNaming />`

### ⭐️ 요약

- 컴포넌트 네이밍 규칙을 이해하고 사용하자

<br />
<br />

## 6. JSX 컴포넌트 함수로 반환

---

### 🌈 결론

```tsx
// 🤔 어떤 형태가 맞을까?
return (
  <div>
    {TopRender()}
    <TopRender />
    {renderMain()}
  </div>
);
```

### ✍️ 내용

```tsx
function ReturnJSXFunction() {
  const TopRender = () => {
    return (
      <header>
        <h1>Clean Code JS</h1>
      </header>
    );
  };

  const renderMain = () => {
    return (
      <main>
        <p>Clean Code</p>
      </main>
    );
  };

  return (
    <div>
      {TopRender()}
      {renderMain()}
    </div>
  );
}
```

**JSX 컴포넌트 함수로 반환시 문제점**

- 스코프가 꼬임
- 언제 어떻게 쓰일지 몰라서 위험
- 컴파일 과정에서 캐치 못하면 치명적인 오류 발생
- 리턴 값이 무엇인지 파악하기 어려움
- props 넣기가 힘듦

### ⭐️ 요약

- 함수로 return 하는 경우 다음과 같은 단점이 발생
  - scope를 알아보기 어려움
  - 반환 값을 바로 알기 어려움
  - props 전달 등 일반적인 패턴이 아님

<br />
<br />

## 7. 컴포넌트 내부에 컴포넌트 선언

### 🌈 결론

```tsx
// ❌
function OuterComponent() {
  const InnerComponent = () => {
    return <div>Inner component</div>;
  };

  return (
    <div>
      <InnerComponent />
    </div>
  );
}

// ✅
const InnerComponent = () => {
  return <div>Inner component</div>;
};

function OuterComponent() {
  return (
    <div>
      <InnerComponent />
    </div>
  );
}
```

### ✍️ 내용

**컴포넌트 내부에 컴포넌트 선언시 문제점**

1. 결합도가 증가함
   - 구조적으로 스코프적으로 종속된 개발이 됨
   - 나중에 확장성이 생겨서 분리될 때 굉장히 힘듦
2. 성능 저하
   - 상위 컴포넌트 리렌더 일어나면 ⇒ 하위 컴포넌트 재 생성

### ⭐️ 요약

- 컴포넌트 내부에 컴포넌트를 선언하면 결합도가 증가하고 성능이 저하될 수 있다.

<br />
<br />

## 8. DisplayName

### 🌈 결론

- 확장성이 높은 컴포넌트를 디버깅하기 위해 `displayName`을 잘 활용하자

### ✍️ 내용

**DisplayName**: 디버깅 하는데 좋은 요소

```tsx
// Case 1
const InputText = forwardRef((props, ref)) => {
	return <input type="text" ref={ref} />;
});

// 만약 🤔 displayName을 작성 안한다면?
InputText.displayName = 'InputText'

// Case 2
const withRouter = (Component) => {
	const WithRouter = (props) => {
		const location = useLocation();
		const navigate = useNavigate();
		const params = useParams();
		const navigationType = useNavigationType();

		return (
			<Component
				{...props}
				location={location}
				navigate={navigate}
				params={params}
				navigationType={navigationType}
			/>
		);
	};
	WithRouter.displayName = Component.displayName ?? Component.name ?? 'WithRouterComponent'

	return WithRouter
};

```

1. displayName을 설정하지 않은 경우

   - React Developer Tools: `<ForwardRef>` 또는 `<Anonymous>`
   - 콘솔 에러 메시지: Warning: Failed prop type: The prop `value` is marked as required in `ForwardRef`, but its value is `undefined`.

2. displayName을 설정한 경우

   - React Developer Tools: `<InputText>`
   - 콘솔 에러 메시지: Warning: Failed prop type: The prop `value` is marked as required in `InputText`, but its value is `undefined`.

### ⭐️ 요약

- React 개발시 디버깅을 위해 displayName을 잘 활용하자.

<br />
<br />

## 9. Component 구성하기

### 🌈 결론

- 개발 진행 시, 어떤 순서 및 흐름으로 설계 하는 것은 중요함.

### ✍️ 내용

```tsx
// ✅ 변하지 않은 값은 컴포넌트 외부로 빼기
const DEFAULT_COUNT = 100;
const DEFAULT_DELAY = 500;

// ✅ 타입 또는 인터페이스도 컴포넌트 밖으로 빼기
interface SomeComponentProps {}

// ✅ 컴포넌트와 관련없는 로직은 컴포넌트 외부로 빼기
const handleClose = () => {
	// Date
	// Local Storage
}

const SomeComponent = ({ prop1, prop2 }: SomeComponentProps) => {
	// ✅ flag 또는 ref는 상단에 표시
	let isHold = false;
	const ref = useRef(null);

	// ✅ React Third-Party 라이브러리의 훅을 사용시 상단에 표시
	const location = useLocation();
	const queryClient = useQueryClient();
	const state = useSelector((state) => state);

	// ✅ 내가 만든 Hooks을 상단에 표시
	const state = useCustomHooks((state) => state);

	// ✅ 컴포넌트 내부 상태를 상단에 표시
	const [state, setState] = useState('someState");

	const onClose = () => handleClose();

	// ✅ Early Return JSX
	if (isHold) {
		return <div>데이터가 존재하지 않습니다.</div>
	}

	// ✅ useEffect 사용시, Main JSX와 가장 가까운 곳에 위치
	// - 최소 1개로 사용할 수 있도록 진행
	useEffect(() => {
	}, []);

	// ✅ JSX 반환은 항상 사전에 개행을 동반
	return (
		<div className="tooltip">
			<div className="msg">Hello World</div>
			<button
				className="close"
				type="button"
				onClick={onClose}
			/>
		</div>
	)
}

// ✅ 컴포넌트 외부로 빼기(컴포넌트 하단)
// - 코드가 많을 경우, 파일로 빼기
const Button = styled.a<{ $primary?: boolean; }>`
	padding: 0.5rem 0;
	transition: all 200ms ease-in-out;
	width: 11rem;

	&:hover {
		filter: brightness(0.85);
	}
`

export default SomeComponent;
```

### ⭐️ 요약

- 개발을 할 때 규칙을 가지고 개발을 진행하자.(컨벤션 설정)

<br />

### 참고

- [클린코드 리액트](https://www.udemy.com/course/clean-code-react/)
