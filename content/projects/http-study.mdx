---
title: 'HTTP 학습 정리'
date: '2024-10-24 09:07:00'
description: HTTP 학습한 내용을 정리했습니다.
published: true
---

# ✅ 1. 인터넷 네트워크

## 인터넷 네트워크

1. 인터넷 통신
2. IP(Internet Protocol)
3. TCP, UDP
4. PORT
5. DNS

<br />

## IP(인터넷 프로토콜)

### 1. IP 역할

- 지정한 IP(IP Address)에 데이터 전달
- 패킷(Packet)이라는 통신 단위로 데이터 전달
  —> 패킷은 약간 편지 같은거? 보내는사람, 받는 사람 적어서 보내는 것처럼 데이터를 전달 할 때 `규칙`이 존재

### 2. 서버 패킷 전달

- 인터넷을 통해 서버(주소)에게 데이터를 전달하는데, 다시 서버에서 클라이언트에게 전달 될 때에는 같은 경로로 오지 않을 수 있음

### 3. IP 프로토콜의 한계 —> TCP, UDP로 해결 가능

- `비연결성` : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- `비신뢰성` : 중간에 패킷이 사라지면? 패킷이 순서대로 안오면?
- `프로그램 구분` : 같은 IP를 사용하는 서버에서 통신하는 App이 둘 2상이면?

<br />

## TCP, UDP

### 1. TCP 특징

- 연결 지향 - TCP 3 Way `HandShake`(가상 연결) : 실제로 연결되지 않고 명목상으로 서버랑 연결했다고 이야기하는 것 사실 그 과정에 많은 서버(노드)가 존재함
- 데이터 전달 보증
- 순서 보장
  - 클라이언트에서 전달한, 패킷 순서를 보장
  - 서버 클라이언트에게 순서를 제대로 보내라고 응답함
- 신뢰 할 수 있는 프로토콜
- 현재는 대부분 TCP 사용
  - 전달하는 데이터 용량이 큼
  - 속도가 느림

### 2. UDP 특징

- 하얀 도화지에 비유(기능이 거의 없음)
- 연결 지향 X
- 데이터 전달 보증 X
- 순서 보장 X
- **데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름**
- IP와 거의 같음 + `PORT` + 체크섬(검증) 정도만 추가
- 애플리케이션에서 추가 작업 필요

<br />

## PORT

### Q) 한번에 2개이상 서버와 연결해야 하면???

- IP 패킷 안에 목적지 IP(서버)외에 해당 서버 안에 PORT를 지정하는 방법으로 해결 가능(이 때, TCP 세그먼트에 출발지 & 목적지 PORT를 기입할 수 있음)

1. IP는 아파트, PORT는 동, 호수라고 생각하면 됨
2. IP에 추가로 각각의 PORT 존재

   ex) `클라이언트 IP`: 100.100.100.1 PORT 8080 —> `서버 IP`: 200.200.200.2 PORT 1120 이런식으로 보냄

3. PORT 번호
   1. 0 ~ 65535 할당가능
   2. 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
      - FTP : 20, 21
      - TELNET : 23
      - HTTP : 80
      - HTTPS : 443

<br />

## DNS

### Q) IP 문제점

- IP가 변경될 수 있거나, IP가 너무 숫자로 되어있어서 복잡함

1. 도메인 네임 시스템 = Domain Name System

   ex) 전화번호부, 도메인 명을 IP주소로 변환

   ![dns.png](/dns.png)

<br />
<br />

# ✅ 2. URI

![uri.png](/uri.png)

### 1. 단어의 뜻

- **URI** = Uniform(리소스 식별하는 통일된 방식) Resource(자원, URI로 식별할 수 있는 모든 것, 제한 없음) Identifier(다른 항목과 구분하는데 필요한 정보
- **URL** = Locator : 리소스가 있는 `위치`를 지정
- **URN** = Name : 리소스에 `이름`을 부여

<br />

### 2. URL 문법

`scheme://[userinfo@]host[:port][/path][?query][#fragment]`

ex) `https://www.google.com:443/search?q=hello&hI=ko`

- 프로토콜 : https
- 호스트명 : www.google.com
- 포트번호 : 443
- 패스 : /search
- 쿼리 파라미터 : q=hello&hI=ko

1. **scheme**
   - 주로 프로토콜 사용
   - 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 ex) http, https, ftp 등
   - http는 80 포트를 주로 사용, https는 443 포트를 주로 사용(포트는 생략 가능)
   - https는 http에 보안 추가(HTTP Secure)
2. **userinfo**
   - URL에 사용자정보를 포함해서 인증
   - 거의 사용하지 않음
3. **host**
   - 호스트명
   - 도메인명 또는 IP 주소를 직접사용가능
4. **port**
   - 접속 포트
   - 일반적으로 생략, 생략시 http는 80, https는 443
5. **path**
   - 리소스 경로(Path), 계층적 구조 ex) /home/file1.jpg, members/100, items/iphone12
6. **query**
   - key=value 형태
   - ?로 시작, &로 추가 가능 ex) keyA=valueA&keyB=valueB
   - query parameter, query thing 등으로 불림
   - 웹서버에 제공하는 파라미터, 문자 형태
7. **fragment**
   - html 내부 북마크 등에 사용
   - 서버에 전송하는 정보 아님

<br />
<br />

# ✅ 3. 모든 것이 HTTP

1. HTTP 메시지에 모든것을 전송

   - HTML, TEXT
   - IMAGE ,음성, 영상, 파일
   - JSON, XML(API)
   - 거의 모든 형태의 데이터 전송 가능
   - 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

2. 기반 프로토콜

   - TCP: HTTP/1.1, HTTP
   - UDP: HTTP/3
   - 점점 HTTP/2, HTTP/3도 점점 증가

3. HTTP 특정
   - 클라이언트 서버 구조
   - 무상태 프로토콜, 비연결성
   - HTTP 메시지
   - 단순함, 확장 가능

<br />

## 클라이언트 서버 구조

- Request - Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답
  —> 각각 역할을 나뉘었다는 것이 포인트
  —> 클라이언트는 UI/UX에 집중하고, 서버는 비즈니스 로직이나, 데이터만 관리
  —> 이렇게 독립적으로 분리하면 각각 고도화 진행 가능
  —> 또한 문제가 발생하면 각각 독립적으로 처리만 하면 됨

<br />

## 무 상태 프로토콜 = Stateless

1. 서버가 클라이언트의 상태를 보존 X

   1. `상태 유지`(stateful)

      —> 중간에 다른 점원이 바뀌면 안됨(만약에 바뀌면 상태 정보를 다른 점원에게 미리 알려줘야 함)

   b. `무상태` (stateless)

   —> 점원이 바뀌어도 정확하게 결과를 얻을 수 있음

   —> 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있음

   —> 응답 서버를 쉽게 바뀔 수 있음(무한한 서버 증설 가능)

2. 장점 : 서버 확장성 높음
3. 단점 : 클라이언트가 추가 데이터 전송
4. `Stateless 실무의 한계`
   - 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있음
   - 무상태 : ex) 로그인이 필요 없는 단순한 서비스 소개 화면
   - 상태 유지: ex) 로그인
     - 로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지
     - 일반적으로 브라우저 쿠키와 서버 세션 등을 이용해서 상태 유지
     - 상태 유지는 최소한만 사용
     - 서버에게 상태를 담아서 전달하기 때문에 상태가 고용량이면 문제가 발생함

<br />

## 비 연결성(connectionless)

### 1. 특징

- HTTP는 기본이 연결을 유지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
  ex) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않음
- 서버 자원을 매우 효율적으로 사용할 수 있음

### 2. 한계와 극복

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만아니라 JS, CSS 추가 이미지 등 수많은 자원이 함께 다운로드
- 지금은 HTTP 지속 연결로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화 ex) UDP

### 3. Stateless를 기억하자(서버 개발자들이 어려워하는 업무)

- 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
  ex) 선착순 이벤트, 명절 KTX 예약, 학과 수업등록

<br />

## HTTP 메시지

### 시작 라인 : 요청 메시지

![/request01.png](/request01.png)

1. start-line = request-line / status-line
2. request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
3. HTTP 메서드 (GET: 조회)
   - 종류 : GET, POST, PUT, DELETE
   - 서버가 수행해야 할 동작 지정 : GET(리소스 조회), POST(요청 내역 처리)
4. 요청 대상(/search?q=hello&hl=ko)
5. HTTP Version

### 시작 라인 : 요청 메시지(요청대상)

1. absolute-path[?query] : (절대경로[?쿼리])
2. 절대경로 = "/"로 시작하는 경로

### 시작 라인 : 응답 메시지

![/request02.png](/request02.png)

1. start-line = request-line / **status-line**
2. **status-line** = HTTP-version SP status-code SP reason-phrase CRLF \*\*\*\*
3. HTTP 상태 코드 : 요청 성공, 실패를 나타냄
   - 200 : 성공
   - 400 : 클라리언트 요청 오류
   - 500 : 서버 내부 오류
4. 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 글

### HTTP 헤더 : 용도

1. HTTP 전송에 필요한 모든 부가 정보

   ex) 메시지 바디의 내용, 메시지 바다의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보

2. 표준 헤더가 너무 많음
3. 필요시 임의의 헤더 추가 가능

### HTTP 메시지 바디 : 용도

1. 실제 전송할 데이터
2. HTML문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

### 단순함 확장 가능

1. HTTP는 단순함
2. HTTP 메시지도 매우 단순
3. 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술

<br />

<br />

### 참고

- [모든 개발자를 위한 HTTP 웹 기본 지식 - 김영한](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC?attributionToken=ChQxMDMxMDMxMDE1NjYzNjU4Nzc5ORANGiNyZWNvbW1lbmRlX3JlY29tbWVuZGVfMTcwMjUyNjQzNDA2NiIXcmVjb21tZW5kZWQtZm9yLXlvdS1jdnIoAA&gad_source=1&gclid=Cj0KCQjwn9y1BhC2ARIsAG5IY-5JlzrjtdmxjRF1KlOKOj-mkkTeNEZYmsMM1bLGQ98vSi01VjhWlcAaAvWIEALw_wcB)
