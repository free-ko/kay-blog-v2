---
title: 'Effective TypeScript 학습 정리'
description: Effective TypeScript 학습한 내용을 알아보자.
date: '2024-11-16 06:22:00'
published: true
---

# ✅ 1장 TS 알아보기

## 아이템 1: TS와 JS의 관계

> “타입스크립트는 자바스크립트의 상위집합(superset)이다”

1. 그렇기 때문에 JS 코드는 이미 TS다.

   - 기존 JS 코드를 타입스크립트로 마이그레이션하는데 큰 이점
   - 타입 구문을 사용하는 순간부터 JS는 TS 영역으로 들어가게 됨

2. 타입 시스템에서는 런타임에 오류를 발생시킬 코드를 미리 찾아낸다.

   ```ts
   const city = [
     { name: 'jeon-ju', food: 'kong-na-mul-kook-bob' },
     { name: 'seoul', food: 'none' },
     // ...
   ];

   for (const localCity of city) {
     console.log(localCity.size); // JS에서는 undefined, TS에서는 에러
   }
   ```

3. 타입을 명시적으로 선언하여 의도를 분명하게 하면 오류를 구체적으로 알 수 있다.

   ```ts
   interface City {
     name: string;
     food: string;
   }

   const city: City[] = [
     { name: 'jeon-ju', food: 'kong-na-mul-kook-bob' },
     { name: 'seoul', food: 'none' },
   ];

   // 🚨 Error
   // 'City' 형식에 'size'이 없습니다.
   for (const localCity of city) {
     console.log(state.size);
   }
   ```

<br />

## 아이템 2: 타입스크립트 설정

1. `tsconfig.json`으로 타입스크립트 설정 작성
   ```js
   {
     "compilerOptions": {
       // ...
     }
   }
   ```
2. `noImplicitAny` : 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어(`any` 타입을 사용하면 에러 설정)

   ```js
   function add(a, b) {
     return a + b;
   }

   // 이를 암시적 any라고 부른다
   // noImplicitAny가 설정되었다면 오류 발생
   function add(a: any, b: any): any;
   ```

3. `strictNullChecks`: `null`과 `undefined`가 모든 타입에서 허용되는지 설정

   ```js
   // strictNullChecks 해제 시
   const x: number = null; // 정상

   // strictNullChecks 설정 시
   // 🚨 에러: 'null' 형식은 'number' 형식에 할당할 수 없습니다.
   const x: number = null;
   ```

<br />

## 아이템 3: 코드 생성과 타입은 관계가 없음

1. TS 컴파일러는 2가지 역할을 수행
   - 최신 TS,JS를 브라우저에서 동작할 수 있도록 구버전 JS로 트랜스파일 함
   - 코드의 타입 오류를 체크 함
2. 타입 오류가 있는 코드도 컴파일 가능
   - 컴파일은 타입 체크와 독립적으로 동작하기 때문
   - 작성한 TS가 유효한 JS라면 TS 컴파일러는 컴파일 진행
3. 런타임에는 타입 체크가 불가능

   - TS의 타입은 ‘제거 가능’ 즉, JS로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 사라짐
   - 런타임에 타입 정보를 유지하는 방법

     - 특정 속성이 존재하는지 체크
     - `태그`기법 : 런타임에 접근 가능한 타입 정보를 명시적으로 저장

       ```ts
       interface Square {
         kind: 'square';
         width: number;
       }

       interface Rectangle {
         kind: 'rectangle';
         height: number;
         width: number;
       }

       // '태그된 유니온(tagged union)'
       type Shape = Square | Rectangle;

       function calculateArea(shape: Shape) {
         if (shape.kind === 'rectangle') {
           shape; // 타입이 Rectangle
           return shape.width * shape.height;
         } else {
           shape; // 타입이 Square
           return shape.width * shape.width;
         }
       }
       ```

4. 타입 연산은 런타임에 영향을 주지 않음
   - 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 JS 연산을 통해 변환을 수행해야 함
5. 런타임 타입은 선언된 타입과 다를 수 있음
   - `switch~case` 구문의 `default` 구문
   - API 요청의 반환값을 사용하는 경우
6. TS 타입으로는 함수를 오버로드할 수 없음

   ```js
   function add(a: number, b: number) {
     return a + b;
   } // 🚨 에러: 중복된 함수 구현입니다.

   function add(a: string, b: string) {
     return a + b;
   } // 🚨 에러: 중복된 함수 구현입니다.
   ```

   - TS 함수 오버로딩은 타입 수준에서만 가능(구현체는 불가)
     ```ts
     function add(a: number, b: number): number;
     function add(a: string, b: string): string;
     ```

7. TS 타입은 런타임 성능에 영향을 주지 않음
   - 타입과 타입 연산자는 JS 변환 시점에 제거되기 때문
   - 런타임 오베허드가 없는 대신, TS 컴파일러는 ‘빌드타임’ 오버헤드가 있음
   - TS 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지, 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있음

<br />

## 아이템 4: 구조적 타이핑에 익숙해지기

1. JS는 본질적으로 덕 타이핑(duck typing) 기반
   - 덕 타이핑 : 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식
2. TS도 JS 처럼 덕 타이핑 동작을 그대로 모델링 함

   ```ts
   interface Vector2D {
     x: number;
     y: number;
   }

   function calculateLength(v: Vector2D) {
     return Math.sqrt(v.x * v.x + v.y * v.y);
   }

   // Vector2D 인터페이스를 확장하며, name 프로퍼티를 추가로 가지고 있음
   // 구조적 타이핑 때문에, Vector2D 인터페이스와 호환
   // NamedVector 인터페이스의 x,y와 Vector2D의 x와 y 동일
   // 따라서 NamedVector 인터페이스를 구현한 객체도
   // calculateLength 함수의 인자로 사용할 수 있음
   interface NamedVector {
     name: string;
     x: number;
     y: number;
   }

   let v: NamedVector = { name: 'vec1', x: 3, y: 4 };
   calculateLength(v); // 5
   ```

3. 구조적 타이핑을 사용하면 유닛 테스트를 쉽게 할 수 있음

   - TS는 테스트 DB가 특정 인터페이스를 충족하는지 확인
   - 추상화(DB)를 함으로써, 로직과 테스트를 특정한 구현으로부터 분리 가능

     ```ts
     interface DB {
       runQuery: (sql: string) => any[];
     }

     function getAuthors(database: DB): Author[] {
       const authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);
       return authorRows.map((row) => ({ first: row[0], last: row[1] }));
     }
     ```

<br />

## 아이템 5: any 타입 지양하기

1. `any` 타입에는 타입 안정성이 없음
   ```ts
   let age: number;
   age = '12' as any; // 정상
   age += 1; // 런타임에 정상, 🚨 age는 '121'
   ```
2. `any`는 함수 시그니처를 무시 함

   ```ts
   function calculateAge(birthDate: Date): number {
     // ...
   }

   let birthDate: any = '1592-05-11';
   calculateAge(birthDate); // 정상 (🚨 추후 에러 발생 가능)
   ```

3. `any` 타입에는 언어 서비스가 적용되지 않음
   - IDE의 자동완성 기능과 적절한 도움말 제공 불가
4. `any` 타입은 코드 리팩터링 때 버그를 감춤
   - `any`가 아닌 구체적인 타입을 사용하여 타입 체커가 오류를 발견하도록 해야 함
5. `any`는 타입 설계를 감춤
   - 애플리케이션 상태 등의 객체 설계 시 `any` 사용을 지양
6. `any`는 타입시스템의 신뢰도를 떨어뜨림
   - 사람은 항상 실수를 함
   - `any` 타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있음

<br />
<br />

# ✅ 2장 TS 타입 시스템

## 아이템 6: 편집기를 사용하여 타입 시스템 탐색하기

- TS에서 실행할 수 있는 프로그램
  - TS 컴파일러(tsc)
  - 단독 실행 가능한 TS 서버
- TS 서버에서 제공하는 언어 서비스를 사용 권장
- 많은 편집기에서 TS가 그 타입을 어떻게 판단하는지 확인 가능
- 편집기 타입 오류를 살펴보는 것도 타입 시스템을 파악하는 데 좋은 방법
- 라이브러리와 라이브러리의 타입 선언
  - Go to Definition 옵션으로 `d.ts`에서 타입 정의 확인 가능

<br />

## 아이템 7: 타입이 값들의 집합이라고 생각하기

1. 런타임시 모든 변수는 JS로 정해진 고유한 값 존재
2. 코드가 실행되기 전 TS가 오류를 체크하는 순간에는 타입을 가지고 있으며, 이는 할당 가능한 값들의 집합
3. 집합의 종류
   - `never` : 아무것도 포함하지 않는 공집합(아무 값도 할당 불가) cf) `void`는 `undefined` 반환
     ```ts
     // 🚨 '12' 형식은 'never' 형식에 할당할 수 없습니다.
     const x: never = 12;
     ```
   - 리터럴(유닛)타입 : 한 가지 값만 포함하는 타입
     ```ts
     type A = 'A';
     ```
   - 유니온 타입 : 두 개 혹은 세 개 값 포함하는 집합들의 합집합
     ```ts
     type AB = 'A' | 'B';
     ```
4. `할당 가능`하다는 뜻 -> 부분 집합
   ```ts
   // 'A'는 집합 {'A', 'B'}의 원소
   const a: AB = 'A';
   ```
5. 실제 다루게 되는 타입은 대부분 범위가 무한대
   ```ts
   type Int = 1 | 2 | 3 | 4 | 5; // | ...
   ```
6. 원소를 서술하는 방법
   ```ts
   interface Identified {
     id: string;
   }
   ```
7. 타입(값의 집합)

   - `&` 연산자는 두 타입의 인터섹션(교집합)을 계산
   - `|` 연산자는 두 인터페이스의 유니온, 교집합이 없는 두 개 이상의 타입에서 사용 시 주의

     ```ts
     interface Person {
       name: string;
     }
     interface Lifespan {
       birth: Date;
       death?: Date;
     }

     type PersonSpan = Person & Lifespan;
     type K = keyof (Person | Lifespan); // 타입이 never
     ```

8. `extends` : ~에 할당 가능한, ~의 부분집합

   - 서브타입 : 어떤 집합이 다른 집합의 부분집합

   ```ts
   interface Vector1D {
     x: number;
   }

   // Vector2D는 Vector1D의 서브타입
   interface Vector2D extends Vector1D {
     y: number;
   }

   // Vector3D는 Vector2D의 서브타입
   interface Vector3D extends Vector2D {
     z: number;
   }
   ```

9. 제네릭에서 `extends`

   ```ts
   // K는 집합 관점에서 string을 상속
   // string 리터럴 타입, string 리터럴 타입의 유니온, string 자신을 포함
   function getKey<K extends string>(val: string, key: K) {
     // ...
   }
   ```

10. 타입이 집합이라는 관점에서 배열과 튜플의 관계 확인

    ```ts
    // 타입은 number[]
    const list = [1, 2];

    // 🚨 'number[]' 타입이 '[number, number]'타입 보다 큰 집합이여서
    // 에러 발생
    // Target requires 2 element(s) but source may have fewer
    const tuple: [number, number] = list;
    ```

11. 트리플

    ```ts
    const triple: [number, number, number] = [1, 2, 3];

    // 🚨 숫자의 length값이 맞지 않기 때문에 할당문에 오류 발생
    const double: [number, number] = triple;
    ```

12. 타입이 값의 집합이라는 뜻은, 동일한 값의 집합을 가지는 두 타입은 같다는 의미

<br />

## ✏️ 아이템 8: 타입 공간과 값 공간의 심벌 구분하기

1. TS 심벌(symbol)은 타입 공간이나 값 공간 중 한 곳에 존재

   ```ts
   interface Cylinder {
     radius: number;
     height: number;
   }

   const Cylinder = (radius: number, height: number) => ({ radius, height });
   ```

   - interface Cylinder는 타입, const Cylinder는 변수
   - 일반적으로 type이나 interface 다음에 나오는 심벌은 타입, const나 let 선언에 쓰이는 것은 값

2. class와 enum 은 상황에 따라 타입과 값 두 가지 모두 가능

   - 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용됨

   ```ts
   // 타입으로 쓰인 Cylinder 클래스
   class Cylinder {
     radius = 1;
     height = 1;
   }

   function calculateVolume(shape: unknown) {
     if (shape instanceof Cylinder) {
       shape; // 정상, 타입은 Cylinder
       shape.radius; // 정상, 타입은 number
     }
   }
   ```

3. `typeof` : 타입에서 쓰일 때와 값에서 쓰일 때가 다름

   - 타입의 관점에서 typeof는 값을 읽어서 TS 타입을 반환
   - 값의 관점에서 typeof는 JS 런타임의 typeof 연산자를 반환(심벌의 런타임 타입을 가리킴)

     ```ts
     // 타입은 Person
     type T1 = typeof p;

     // 타입은 (p: Person, subject: string, body: string) => Response
     type T2 = typeof email;

     // 값은 'object'
     const v1 = typeof p;

     // 값은 'function'
     const v2 = typeof email;
     ```

4. 클래스

   ```ts
   // 타입이 typeof Cylinder
   type T = typeof Cylinder;

   declare let fn: T;
   const c = new fn(); // 타입이 Cylinder
   ```

   - InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입 전환 가능
     ```ts
     type C = InstanceType<typeof Cylinder>; // 타입이 Cylinder
     ```

5. 속성 접근자 []
   - `obj['field']`와 `obj.field`는 값이 동일하더라도 타입은 다를 수 있으므로, 타입의 속성을 얻을 때는 `obj['field']`를 지향

<br />

## ✏️ 아이템 9: 타입 단언보다는 타입 선언을 사용하기

1. 타입 단언은 오류를 발견하지 못 함

   ```ts
   interface Person {
     name: string;
   }

   // 🚨 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
   const kay: Person = {};
   const bob = {} as Person; // 오류 없음
   ```

   - 속성을 추가할 때도 마찬가지(타입 선언문에서는 잉여 속성 체크가 동작하지만, 단언문에서는 적용되지 않음)

2. 화살표 함수의 타입 선언

   ```ts
   const people = ['kay', 'bob', 'jun'].map((name) => ({ name }));

   // Person[]을 원했지만 결과는 { name: string; }[]...
   ```

   - 단언문 대신 화살표 함수의 반환 타입을 선언
     ```ts
     // 타입은 Person[]
     const people = ['kay', 'bob', 'jun'].map((name): Person => ({ name }));
     ```
     - 그러나 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 오류가 정확하게 표시 됨

3. 타입 단언이 꼭 필요한 경우

   - 타입 체커가 추론한 타입보다 개발자가 판단하는 타입이 더 정확할 때

   ```ts
   document.querySelector('#myButton').addEventListener('click', (e) => {
     e.currentTarget; // 타입은 EventTarget

     // 타입은 HTMLButtonElement
     const button = e.currentTarget as HTMLButtonElement;
   });
   ```

4. `!` 문법을 사용해서 `null`이 아님을 단언하는 경우

   ```ts
   // 타입은 HTMLElement | null
   const elNull = document.getElementById('foo');

   // 타입은 HTMLElement
   const el = document.getElementById('foo')!;
   ```

5. 타입 단언문으로 임의의 타입 간에 변환
   - `A`가 `B`의 부분집합(서브타입)인 경우 사용

<br />

## ✏️ 아이템 10 : 객체 래퍼 타입 피하기

1. JS는 기본형과 객체 타입을 서로 자유롭게 변환 가능(래퍼 객체)
2. string 기본형과 String 래퍼 객체가 항상 동일하게 동작하는 것은 아님
   - String 객체는 오직 자기 자신하고만 동일하다
     ```ts
     'hello' === new String('hello'); // false
     new String('hello') === new String('hello'); // false
     ```
3. TS는 기본형과 객체 래퍼 타입을 별도로 모델링 함
   ```ts
   // 🚨 'String' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
   // 'String'은 Object 임
   function isGreeting(phrase: String) {
     return ['hello', 'good day'].includes(phrase);
   }
   ```
   - string은 String에 할당할 수 있지만, String은 string에 할당할 수 없음
   - TS가 제공하는 타입 선언은 전부 기본형 타입

<br />

## ✏️ 아이템 11: 잉여 속성 체크의 한계 인지하기

1. 타입이 명시된 변수에 객체 리터럴을 할당할 때 TS는 해당 타입의 속성이 있는지, 그리고 ‘그 외의 속성은 없는지’ 확인

   ```ts
   interface Room {
     numb: number;
     size: number;
   }

   const room = {
     numb: 1,
     size: 10,
     bed: 4,
   };

   const secondRoom: Room = room; // 정상
   ```

   - room 타입은 Room 타입의 부분 집합을 포함하므로, Room에 할당 가능하며 타입 체커도 통과 함
   - 잉여 속성 체크는 할당 가능 검사와는 별도의 과정

2. TS는 런타임 오류 뿐 아니라, 의도와 다르게 작성된 코드까지 찾음

   ```ts
   interface Options {
     title: string;
     darkMode?: boolean;
   }

   function createWindow(options: Options) {
     if (options.darkMode) {
       setDarkMode();
     }
   }

   createWindow({
     title: 'Spider Solitaire',
     darkmode: true, // 🚨 에러 darkMode 아님?
   });
   ```

   - 런타임에 에러가 발생하지 않지만, TS에서 에러가 발생 함

3. `Options`는 넓은 타입으로 해석 됨

   ```ts
   interface Options {
     title: string;
     darkMode?: boolean;
   }

   const o1: Options = document; // 정상
   const o2: Options = new HTMLAnchorElement(); // 정상
   ```

   - `document`와 `HTMLAnchorElement`의 인스턴스 모두 string 타입인 title 속성을 갖고 있기 때문에 할당문 정상

4. 잉여 속성 체크는 객체 리터럴만 체크 함

   ```ts
   interface Options {
     title: string;
     darkMode?: boolean;
   }

   // 🚨 에러 - darkMode 아님?
   const o1: Options = { darkmode: true, title: 'Ski Free' };

   const intermediate = { darkmode: true, title: 'Ski Free' };
   const o2: Options = intermediate; // 정상

   // 타입 단언문을 사용할 때도 적용되지 않는다
   const o3: Options = { darkmode: true, title: 'Ski Free' } as Options; // 정상
   ```

<br />

## ✏️ 아이템 12: 함수 표현식에 타입 적용하기

1. TS는 함수 선언문이 아닌 함수 표현식을 권장
   - 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점 존재(시그니처)
     ```ts
     type DiceRollFn = (sides: number) => number;
     const rollDice: DiceRollFn = (sides) => {};
     ```
2. 반복되는 함수 시그니처를 하나의 함수로 통합하여 불필요한 코드의 반복을 줄일 수 있음
   - 라이브러리는 공통 함수 시그니처를 타입으로 제공 ex) 리액트 MouseEventHandler
3. 시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입 적용 가능

   - ex) fetch 함수

   ```ts
   // 타입이 Promise<Response>
   const responsePromise = fetch('/search?by=Kay');
   ```

   - 응답의 데이터를 추출

   ```ts
   async function getSearch() {
     const response = await fetch('/search?by=Kay');
     const data = await response.json();

     return data;
   }
   ```

   - 이때 /search가 존재하지 않는 API거나 fetch가 실패하는 경우 버그가 발생 함
   - 상태 체크를 수행해 줄 checkedFetch 함수 작성
   - 함수 선언문을 함수 표현식으로 바꾸고, 함수 전체에 타입을 적용

   ```ts
   // lib.dom.d.ts
   declare function fetch(
     input: RequestInfo,
     init?: RequestInit
   ): Promise<Response>;

   const checkedFetch: typeof fetch = async (input, init) => {
     const response = await fetch(input, init);

     if (!response.ok) {
       throw new Error('Request failed: ' + response.status);
     }
     return response;
   };
   ``;
   ```

<br />

## 참고

- [이펙티브 타입스크립트 Study](https://github.com/pagers-org/Effective-TypeScript)
- [이펙티브 타입스크립트 책](http://www.yes24.com/Product/Goods/102124327)
- [구조적 타이핑](https://yozm.wishket.com/magazine/detail/1661/)
- [타입을 집합의 관점에서 바라보기](https://yozm.wishket.com/magazine/detail/1661/)
- [타입을 집합으로 생각하기](https://velog.io/@dltlsgh5/typescript%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%91%ED%95%A9%EC%9C%BC%EB%A1%9C-%EC%83%9D%EA%B0%81%ED%95%98%EA%B8%B0)
