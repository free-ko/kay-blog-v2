---
title: 'JS 번들러 비교'
date: '2024-08-08 05:53:00'
description: JS 번들러들에 대해 알아보자.
published: true
---

# Webpack

`Webpack`은 가장 오래된 번들러 중 하나로, 여러 파일을 묶어주는 데 매우 강력한 도구입니다. 설정이 다소 복잡할 수 있지만, 확장성과 성능 면에서 매우 안정적입니다. `Webpack`은 복잡한 애플리케이션에서도 안전하게 `code splitting`을 해주며, 트리셰이킹 기능을 통해 불필요한 코드를 제거할 수 있습니다.설정이 다소 복잡할 수 있지만, 커뮤니티가 크고 레퍼런스가 많아 안정적인 선택이 될 수 있습니다.

### 주요 특징

1. **JS 이외의 파일 처리**: CSS, 이미지 파일과 같은 JS 이외의 파일들을 처리하려면 별도의 `loader`가 필요합니다. 예를 들어, `style-loader, css-loader` 등을 사용해 CSS 파일을 처리할 수 있습니다.
2. **안전한 Code Splitting**: `Parcel`이나 `Rollup`보다 코드 스플리팅의 안전성이 높아 복잡한 의존성 트리에서도 안정적으로 번들을 나눌 수 있습니다.
3. **Webpack Dev Server**: `webpack-dev-server`를 사용해 실시간으로 개발 환경에서 코드 변경을 반영하고, 자동으로 브라우저를 새로고침할 수 있습니다.
4. **역사가 깊고 안정적**: `Webpack`은 오랜 역사를 가진 번들러로, 많은 서드파티 플러그인과 레퍼런스를 통해 안정적인 사용이 가능합니다.
5. **Tree-shaking 지원**: Webpack은 트리셰이킹을 통해 사용하지 않는 코드를 제거할 수 있지만, ES6 모듈에서만 작동합니다. `package.json`의 `{ sideEffects: false }` 항목을 통해 `side effects`가 없는 코드를 명시적으로 알려줘야 불필요한 코드가 제거됩니다.
6. **복잡한 애플리케이션에 적합**: Webpack은 많은 서드파티 플러그인을 필요로 하며, 복잡한 애플리케이션에서 활용하기 적합합니다.

### 예시 코드

아래는 Webpack을 사용하여 JS, CSS, 이미지 파일을 번들링하는 예시입니다. 이 예시는 기본적인 설정을 포함하고 있습니다.

```js
// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'production', // 'development' 또는 'production' 모드를 선택
  entry: './src/index.js', // 엔트리 파일 설정
  output: {
    filename: 'bundle.js', // 출력 파일 이름
    path: path.resolve(__dirname, 'dist'), // 출력 파일 경로
    clean: true, // 기존 번들 파일을 제거하고 새로 생성
  },
  module: {
    rules: [
      {
        test: /\.css$/, // CSS 파일을 처리하는 룰
        use: ['style-loader', 'css-loader'], // style-loader와 css-loader 사용
      },
      {
        test: /\.(png|svg|jpg|gif)$/, // 이미지 파일을 처리하는 룰
        type: 'asset/resource', // 파일을 별도의 리소스로 처리
      },
    ],
  },
  optimization: {
    splitChunks: {
      chunks: 'all', // 코드 스플리팅 설정
    },
    usedExports: true, // 사용되지 않는 export 제거 (트리셰이킹)
  },
};
```

### Tree-shaking 적용 방법

`tree-shaking`을 적용하려면 ES6 모듈을 사용해야 하며, `package.json`에서 `side effects`를 명시해야 합니다. 이를 통해 `Webpack`은 불필요한 코드를 안전하게 제거할 수 있습니다.

```json
// package.json
{
  "name": "my-webpack-project",
  "version": "1.0.0",
  "main": "index.js",
  "sideEffects": false, // 트리셰이킹 적용을 위한 설정
  "dependencies": {
    // 프로젝트 의존성 목록
  }
}
```

### Webpack Dev Server 설정

개발 환경에서 실시간 반영을 위해 `webpack-dev-server`를 설정할 수 있습니다. 아래 예시는 `webpack-dev-server`를 통해 브라우저가 자동으로 새로고침되도록 설정한 코드입니다.

```js
// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'development', // 개발 모드 설정
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'dist'), // 개발 서버의 기본 경로
    compress: true, // 파일 압축
    port: 9000, // 서버 포트 번호
    hot: true, // 핫 리로딩(HMR) 지원
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
};
```

<br />

# Parcel

Parcel은 설정 없이 바로 사용할 수 있는 `zero-configuration` 번들러로, 간편함과 빠른 빌드 속도로 주목받고 있습니다.
`Rust`로 작성된 강력한 컴파일러를 기반으로 하여 개발 속도를 크게 향상시키며, 다양한 파일 형식을 플러그인 없이 기본적으로 처리할 수 있는 것이 큰 장점입니다.

### 주요 특징

1. **zero-configuration**: Parcel의 가장 큰 장점 중 하나는 별도의 설정 없이 바로 사용할 수 있다는 점입니다. 개발자가 따로 번들링을 위한 설정을 작성할 필요 없이, 기본적인 JS, CSS, HTML, 이미지 파일 등 대부분의 파일을 자동으로 처리합니다. 이는 프로젝트를 시작할 때 빠르게 설정을 끝내고 개발에 집중할 수 있게 도와줍니다.
2. **빠른 빌드 속도**: Parcel은 성능 최적화를 위해 Rust로 작성된 JS 컴파일러와 CSS transformer, sourcemap 기능을 제공합니다. 특히, SWC(또한 Rust 기반)를 활용하여 ES6 및 CommonJS 모듈에 대해 트리셰이킹과 핫 리로딩(HMR)을 지원합니다.

   - `병렬 빌드`: 워커 쓰레드를 사용하여 여러 작업을 동시에 처리할 수 있어 빠른 빌드를 제공합니다.
   - `캐싱 기능`: 모든 빌드 단계(트랜스포메이션, 의존성 해결, 번들링, 최적화 등)가 캐시되며, 코드가 바뀌면 부분적으로만 캐시가 무효화되기 때문에 빠른 빌드를 유지합니다. 이는 Webpack보다 최대 20배 빠른 속도를 제공합니다.

3. **다양한 파일 형식 기본 지원**: Parcel은 플러그인 없이도 JS, CSS, HTML, 이미지 파일 등 다양한 파일 형식을 기본적으로 지원합니다. 별도의 loader 없이도 파일들을 처리할 수 있기 때문에, 설정이 간편합니다. HTML 파일을 직접 읽어서 JS 엔트리포인트를 지정할 필요도 없습니다.
4. **트랜스파일러 기본 지원**: Parcel은 Babel, PostCSS, PostHTML 같은 트랜스파일러들을 기본으로 지원합니다. `.babelrc, .postcssrc` 같은 설정 파일을 프로젝트 루트에 추가하면 Parcel이 이를 자동으로 인식해 변환 작업을 수행합니다. 심지어 `node_modules` 폴더에 있는 모듈까지도 변환해줍니다.
5. **동적 import와 코드 스플리팅**: Parcel은 동적 import를 사용해 번들을 자동으로 분할할 수 있습니다. 초기 로드 시 필요한 것들만 로드하도록 설정할 수 있으며, 개발 환경에서는 브라우저에서 요청이 있을 때까지 번들링을 지연할 수 있습니다. 이로 인해 실제 필요한 페이지만 로드되며, `dev server` 실행 시간을 줄여줍니다.
6. **핫 모듈 리플레이스먼트(HMR)**: Parcel은 HMR(Hot Module Replacement)을 기본으로 지원합니다. 코드 수정 사항이 발생할 때 전체 페이지를 다시 로드하지 않고도 변경된 모듈만 교체할 수 있습니다. 특히 `React`와 `Vue` 같은 프레임워크와 함께 사용할 때 `Fast Refresh` 기능을 통해 더욱 빠른 피드백을 받을 수 있습니다.
7. **프로덕션 자동 최적화**: Parcel은 프로덕션 빌드 시 여러 가지 최적화 작업을 자동으로 수행합니다.

   - Tree Shaking: 사용되지 않는 코드와 CSS 모듈, 동적 모듈 import 등을 자동으로 제거합니다.
   - 최소화 및 난독화: JS, CSS, HTML, SVG 파일을 자동으로 최소화(minification)하고 난독화하여 파일 크기를 줄입니다.
   - 이미지 최적화: 이미지 파일도 최적화하여 빠른 로딩을 지원합니다.

8. **코드 스플리팅**: 여러 파트에서 동일한 모듈을 사용하고 있는 경우, Parcel은 해당 모듈을 자동으로 별도의 번들로 분리하여 공통 번들로 만들어줍니다. CSS도 마찬가지로 지원되어, 중복된 CSS가 여러 파일에 포함되지 않도록 최적화할 수 있습니다.
9. **브라우저 캐시를 위한 Content Hash 제공**: Parcel은 모든 output 파일에 대해 `content hash`를 제공하여 브라우저 캐시에 유리합니다. 이를 통해 배포된 파일이 수정되었을 때 캐시가 자동으로 무효화되고, 사용자가 최신 버전의 파일을 받아볼 수 있게 됩니다.

### Parcel 예시 코드

Parcel을 사용하는 예시 코드는 매우 간단합니다. 별도의 설정 파일 없이 `package.json` 파일에서 간단한 명령어만 추가하면, Parcel이 알아서 설정을 처리해줍니다.

```json
// package.json
{
  "scripts": {
    "dev": "parcel index.html", // 개발 서버 실행
    "build": "parcel build index.html" // 프로덕션 빌드
  },
  "devDependencies": {
    "parcel": "^2.0.0"
  }
}
```

**주요 파일 구조**

Parcel은 기본적으로 HTML 파일을 진입점으로 사용하며, 별도의 엔트리 포인트 설정이 필요하지 않습니다. 아래는 Parcel을 사용하는 프로젝트의 기본 파일 구조입니다.

```bash
├── src/
│   ├── index.js        # JS 파일
│   ├── style.css       # CSS 파일
├── index.html          # HTML 파일 (진입점)
└── package.json        # Parcel 관련 명령어 포함

```

<br />

# Rollup

Rollup은 ES6 모듈(ESM)을 기본으로 지원하며, 매우 깔끔하고 최적화된 번들링 결과물을 생성하는 번들러입니다. 주로 `Tree-Shaking`을 통해 사용하지 않는 코드를 제거하고, 여러 모듈을 하나의 파일로 합치는 데 강점을 보입니다. Rollup은 간단한 설정으로도 매우 효율적인 번들링을 제공하지만, JS 이외의 파일을 처리하거나 개발 서버 및 HMR을 사용하려면 플러그인이 필요합니다.

### 주요 특징

1. **ES6 모듈 형식 지원**: Rollup은 ES6 모듈(ESM) 형식으로 빌드 결과물을 생성합니다. Webpack이 기본적으로 CommonJS 형태만을 지원하는 반면, Rollup은 모던 자바스크립트 모듈 형식을 사용해 더 효율적으로 코드를 관리할 수 있습니다.
2. **단일 모듈로 최적화된 코드 생성**: Rollup은 여러 개의 모듈을 하나의 단일 모듈로 결합해 최적화된 코드를 생성합니다. 번들링 과정에서 모든 코드를 동일한 수준으로 호이스팅하여 한 번에 처리하므로, 중복된 코드를 효과적으로 제거할 수 있습니다. 이는 특히 `code splitting`과 중복 제거에 강점을 보이며, Webpack의 `ModuleConcatenationPlugin`과 비슷한 역할을 합니다.
3. **기본 Tree Shaking 지원**: Rollup은 사용되지 않는 코드를 제거하는 트리셰이킹 기능을 기본으로 제공합니다. 자바스크립트 외의 파일을 처리할 때도 플러그인을 사용하여 코드를 정적으로 분석하고, 미사용 코드를 제외합니다. 이를 통해 번들의 크기를 최소화할 수 있습니다.
4. **개발 서버 및 HMR**: Rollup은 기본적으로 개발 서버나 핫 모듈 리플레이스먼트(HMR)를 제공하지 않습니다. 하지만 추가 플러그인을 설치하면 라이브 리로딩과 HMR을 사용할 수 있습니다. 예를 들어, `rollup-plugin-serve`로 개발 서버를 설정하고 `rollup-plugin-livereload`로 라이브 리로딩을 구현할 수 있습니다.
5. **해시 캐스캐이딩이 약함**: Rollup은 파일의 해시가 변경되면 그 파일을 참조하는 다른 파일들의 해시도 자동으로 변경되는 해시 캐스캐이딩 기능이 약합니다. 이는 번들링 과정에서 캐싱이나 파일 무결성 보장 측면에서 다소 불리할 수 있습니다.
6. **CommonJS 의존성 및 서드파티 라이브러리 통합**: Rollup은 ES6 모듈을 기본으로 사용하기 때문에 CommonJS 모듈과의 호환성에서 제약이 있을 수 있습니다. 이를 해결하기 위해 `@rollup/plugin-commonjs` 플러그인을 사용하는 경우가 많습니다. 또한, 서드파티 라이브러리와의 통합이 Webpack보다 다소 어려울 수 있습니다. 하지만 필요한 플러그인들을 적절히 활용하면 충분히 해결 가능한 문제입니다.

### 예시 코드

아래는 Rollup을 사용하여 기본적인 ES6 모듈을 번들링하는 예시입니다. Tree-Shaking 기능을 활용하고, CommonJS 모듈을 처리하는 플러그인도 함께 사용합니다.

```js
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { terser } from 'rollup-plugin-terser';

export default {
  input: 'src/index.js', // 진입점 설정
  output: {
    file: 'dist/bundle.js', // 번들링된 결과물 파일
    format: 'esm', // ES6 모듈 형식으로 출력
    sourcemap: true, // 디버깅을 위한 소스맵 생성
  },
  plugins: [
    resolve(), // node_modules에서 모듈을 불러오기 위한 플러그인
    commonjs(), // CommonJS 모듈을 ES 모듈로 변환하는 플러그인
    terser(), // 번들을 최소화하여 최적화
  ],
};
```

**플러그인을 사용한 개발 서버 설정**

Rollup은 기본적으로 개발 서버를 제공하지 않지만, `rollup-plugin-serve`와 `rollup-plugin-livereload` 플러그인을 사용하면 개발 서버와 라이브 리로드 기능을 설정할 수 있습니다.

```js
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import serve from 'rollup-plugin-serve'; // 개발 서버 플러그인
import livereload from 'rollup-plugin-livereload'; // 라이브 리로드 플러그인

export default {
  input: 'src/index.js',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  plugins: [
    resolve(),
    commonjs(),
    serve({
      open: true, // 브라우저에서 자동으로 열기
      contentBase: 'dist', // 서버의 루트 경로
      port: 3000, // 개발 서버 포트
    }),
    livereload('dist'), // dist 폴더를 모니터링하여 변경 시 리로딩
  ],
};
```

<br />

## Esbuild

- Go로 작성되어 있어 빠른 번들링 속도
- 코드 파싱, 출력과 소스맵 생성을 모두 병렬로 처리함
- CommonJS, ES6, JSX, Typescript, Tree shaking을 지원함
  - ES5 이하의 문법을 아직 100% 지원하지 않기 때문에, IE 대응이 어려움
- 빌드 도구이지 통합 툴이 아니라서, 기존의 툴(webpack, parcel, rollup 등)을 사용해야 함 → snowpack 또는 vite와 결합하여 사용함
- 버전 1.0도 안됨
- 대규모 프로덕션 사이트에는 사용 지양
- live/hot reload(HMR) 지원하지 않음
- PostCSS와 기타 전처리기 자동 변환 X
- AST 변환 작업을 지원하지 않음 (플러그인 필요)

<br />

## Vite

- react, vue, preact를 지원(CRA, vue-cli의 대체재)
- 사전 번들링(Pre-bundling)
  - esbuild를 사용하여 기존 번들링 대비 10-100배 빠른 속도
- Native ESM 제공 (dev)
  - 번들링 없이 온디맨드(on-demand)로 파일을 제공할 수 있음
  - JSX, CSS 또는 Vue/Svelte 컴포넌트와 같이 컴파일링이 필요하고, 수정이 잦은 Non-plian JS 소스코드 → Native ESM을 이용해 소스코드를 제공하여, 브라우저를 번들러처럼 사용함
- production에서는 rollup을 사용
  - production에서는 esbuild가 아닌 번들링 방식을 사용하는 이유는 프로덕션에서 번들 되지 않은 ESM을 가져오는 것은 중첩된 import로 인한 추가 네트워크 통신으로 인해 여전히 비효율적임
  - 프로덕션 환경에서 최적의 로딩 성능을 얻으려면 트리 셰이킹, 지연 로딩 및 청크 파일 분할(더 나은 캐싱을 위해)을 이용하여 번들링 하는 것이 더 좋음
  - Esbuild는 번들링에 필수적으로 요구되는 기능인 코드 분할(Code-splitting) 및 CSS와 관련된 처리가 아직 미비함
- esbuild(dev)와 rollup(prod)으로 구성되어 있음
- dependencies(패키지)와 소스코드를 분리하여 빌드함
  - 패키지: 설치 후에 내용이 바뀌지 않음
  - 소스코드: 빈번하게 바뀜
- 빠른 HMR 지원
  - 번들러가 아닌 native ESM을 사용하기 때문(브라우저가 곧 번들러)
  - 모듈 수정 시 해당 부분만 교체하고, 브라우저에서 해당 모듈을 요청할 때까진 사용되지 않음
- 기본적으로 TypeScript, JSX, CSS 등을 지원
  - 내부적으로 esbuild를 사용
- 빌드 최적화
  - CSS를 자동으로 추출해 파일로 분리
  - 빌드 시 Direct import 구문에 대해 `<link ref="modulepreload">` 디렉티브를 이용해 미리 모듈을 캐싱하도록 자동으로 변환
  - 모든 Direct import 구문을 preload하여 불필요한 네트워크 요청을 줄임
- tree-shaking, 코드 스플리팅을 지원하지 않음
- rollup 번들러를 사용한 pre-configured 빌드 환경에서 rollup config를 뜯어내기가 아주 어려움

<br />

## 참고

- [참고1](https://webpack.js.org/concepts/)
- [참고2](https://webpack.js.org/concepts/why-webpack/)
- [참고3](https://parceljs.org/)
- [참고4](https://heropy.blog/2018/01/20/parcel-1-start/)
- [참고5](https://rollupjs.org/guide/en/)
- [참고6](https://dantechblog.gatsbyjs.io/posts/rollup/)
- [참고7](https://vitejs-kr.github.io/guide/why.html)
- [참고8](https://vitejs-kr.github.io/guide/features.html#build-optimizations)
- [참고9](https://engineering.ab180.co/stories/webpack-to-vite)
- [참고10](https://ui.toast.com/posts/ko_20220127)
- [참고11](https://velog.io/@subin1224/Parcel-vs-Rollup-vs-Webpack-비교)
