---
title: 'Clean React 05 - Hooks'
date: '2024-09-13 07:27:00'
description: Hook에 대해 자세히 알아보자.
published: true
---

# 1. Hooks API

---

### 🌈 결론

- Hook이 왜 생겨났는지 알고 쓰자

### ✍️ 내용

### 1. Hooks API 도입 배경

**1.1 기존 패턴들의 한계**

- React에서는 `HOC(고차 컴포넌트)`, `Render Props`, 그리고 `클래스 컴포넌트(SFC) 패턴`을 사용하여 컴포넌트 로직을 재사용하거나 상태 관리를 해왔습니다. 하지만 이러한 패턴들에는 몇 가지 문제점이 있었습니다.

- `HOC`의 단점

  - 깊은 컴포넌트 트리(Wrapper Hell): 여러 HOC가 중첩되면 코드가 복잡해지고 디버깅이 어려워집니다.
  - 코드 가독성 저하: 로직을 이해하기 어려워지며, 코드가 장황해질 수 있습니다.

- `Render Props`의 단점

  - Prop Drilling: 여러 컴포넌트에 걸쳐 props를 전달해야 할 때, 중첩된 구조로 인해 관리가 힘들어집니다.
  - 가독성 문제: 함수 형태로 props를 전달하는 방식이 때때로 복잡하고 헷갈릴 수 있습니다.

- `클래스 컴포넌트`의 단점

  - 상태 관리의 복잡성: this 키워드를 사용해야 하는 불편함, 그리고 state와 lifecycle 메서드를 나눠서 관리하는 불편함이 있었습니다.

**1.2. Hooks의 등장**

- React 팀은 이러한 복잡함을 줄이고, 더 직관적인 상태 관리와 사이드 이펙트 관리 방법을 제공하기 위해 Hooks API를 도입했습니다.

### 2. 기존 패턴들과 Hooks 비교

**2.1. HOC(Higher-Order Component)**

- 기능: 컴포넌트를 감싸서 새로운 기능을 추가하는 패턴.
- 문제점: HOC의 중첩은 코드 가독성을 떨어뜨리고, 컴포넌트 계층이 깊어지면서 디버깅이 어려워집니다.

  ```tsx
  // HOC는 여전히 유용할 수 있지만, 중복 로직이 많고 트리 구조가 복잡해질 수 있습니다.
  const EnhancedComponent = higherOrderComponent(WrappedComponent);
  export default connect(mapStateToProps, mapDispatchToProps)(TodoApp);
  ```

**2.2 Render Props**

- 기능: 컴포넌트가 함수형 props를 통해 자식에게 렌더링 로직을 전달하는 패턴.
- 문제점: 중첩된 함수 호출이 많아지면 가독성이 떨어집니다.

  ```tsx
  <DataProvider render={(data) => <h1>Hello {data.target}</h1>} />
  ```

**2.3. 클래스 컴포넌트와 SFC(Stateless Functional Component)**

- 클래스 컴포넌트는 this를 관리해야 하고, state와 라이프사이클 메서드를 분리해서 사용해야 하는 복잡함이 있었습니다.

  ```tsx
  class ClassComponent extends React.Component {
    render() {
      return <div>{this.props.name}</div>;
    }
  }
  ```

- SFC는 상대적으로 간단하지만, 상태 관리와 사이드 이펙트 관리에 한계가 있었습니다.

      ```tsx
      const StatelessComponent = (props) => <div>{props.name}</div>;
      ```

### 3. Hooks의 핵심 개념

**3.1 `useState`**

- 함수형 컴포넌트에서 상태를 관리할 수 있게 해줍니다.

      ```tsx
      const [state, setState] = useState(initialState);
      ```

**3.2. `useEffect`**

- 사이드 이펙트(예: 데이터 가져오기, DOM 업데이트)를 처리합니다. 클래스 컴포넌트의 componentDidMount, componentDidUpdate와 비슷한 역할을 합니다.

      ```tsx
      useEffect(() => {
        document.title = `You clicked ${count} times`;
      }, [count]); // count가 변경될 때마다 실행
      ```

**3.3. 그 외 주요 Hooks**

- `useContext`: Context API와 함께 상태를 쉽게 공유.
- `useReducer`: 복잡한 상태 로직을 간결하게 처리.
- `useMemo`, `useCallback`: 성능 최적화를 위한 메모이제이션 제공.

### 4. Hooks가 제공하는 이점

**4.1. 코드 간결화**

- 함수형 컴포넌트에서도 상태와 라이프사이클 관리가 가능하여, 클래스형 컴포넌트에서의 복잡한 코드가 많이 줄어듭니다.

**4.2. 로직 재사용**

- HOC나 Render Props 없이도 여러 컴포넌트에서 로직을 쉽게 공유할 수 있습니다. 커스텀 Hook을 만들어 재사용할 수 있습니다.

  ```tsx
  function useCustomHook() {
    // 커스텀 로직
  }
  ```

**4.3. 더 나은 가독성**

- 함수형 컴포넌트에 로직을 분리해서 작성할 수 있기 때문에, 코드 가독성이 높아집니다.

### ⭐️ 요약

- Hooks는 기존의 HOC, Render Props, 클래스 컴포넌트의 복잡성을 해결하기 위해 도입되었습니다.
- Hooks를 사용하면 코드가 간결해지고, 재사용 가능한 로직을 쉽게 만들 수 있으며, 함수형 컴포넌트에서 상태와 사이드 이펙트를 관리할 수 있습니다.

<br />
<br />

# 2. useEffect 기명함수와 함께 사용하기

---

### 🌈 결론

- `useEffect` 에러 파악할 때, 기명함수 사용하면 파악하기 쉬움

### ✍️ 내용

### 1. 기명함수를 사용한 useEffect 이점

**1.1 에러 디버깅의 용이성**

- `useEffect` 내에서 기명함수를 사용하면, 함수가 어디서 호출되는지 로그를 통해 쉽게 파악할 수 있습니다.
- `console.log`, `React DevTools`, `모니터링 툴` 등을 사용할 때, 익명 함수로 넘기면 어디서 에러가 발생했는지 파악하기 어렵지만, 기명함수를 사용하면 로그에 함수 이름이 찍혀 에러 위치를 빠르게 찾을 수 있습니다.

**1.2 코드 가독성 및 유지보수 향상**

- 기명함수를 사용하면, 함수의 역할과 의도를 함수명에서 직접적으로 알 수 있습니다. 이는 코드 리뷰 시에도 도움이 되고, 나중에 코드를 유지보수할 때 로직을 빠르게 이해하는 데 유리합니다.

**1.3 코드 재사용성 증가**

- 복잡한 로직을 가진 경우, 해당 로직을 기명함수로 분리하면 동일한 로직을 다른 곳에서도 재사용할 수 있습니다. `useEffect` 안에서 로직이 여러 번 반복되기보다 함수로 분리하여 재사용할 수 있다는 점에서 코드 효율성을 높입니다.

### 2. 기명함수를 활용한 useEffect 예시

```tsx
// 기명함수를 사용하여 로그 확인 및 유지보수 용이하게
useEffect(
  function trackIsInView() {
    // 'trackIsInView' 함수 내 로직 실행
    console.log('Component in view logic executed.');
  },
  [isInView]
);

useEffect(
  function handlePopState() {
    if (navigationType === 'POP') {
      console.log('POP navigation detected.');
      // some logic for handling 'POP' navigation
    }
  },
  [navigationType]
);

// 의존성이 없는 초기화 로직에 기명함수 사용
useEffect(function initializeComponent() {
  console.log('Component initialized.');
  // 초기화 관련 로직
}, []);

// 이벤트 핸들링 시, 기명함수로 이벤트 추가 및 제거
useEffect(function manageDocumentEvent() {
  const handleEvent = () => {
    console.log('Document event handled.');
    // some logic
  };
  document.addEventListener('eventName', handleEvent);

  return function removeDocumentEvent() {
    document.removeEventListener('eventName', handleEvent);
    console.log('Document event listener removed.');
  };
}, []);
```

### 3. 보충 설명

**3.1 함수명 선택**

- 함수명은 해당 로직이 무엇을 하는지 명확하게 설명할 수 있어야 합니다. 위 예시에서 `trackIsInView`는 컴포넌트가 보이는지 여부를 추적하는 역할을 직관적으로 나타냅니다. `handlePopState`는 브라우저 히스토리 변경 시 POP 상태를 처리하는 함수로 명명되어 코드의 의도를 잘 전달합니다.

**3.2 의존성 배열 관리**

- 기명함수를 사용하더라도, `useEffect`에서 의존성 배열을 적절하게 관리하는 것이 중요합니다. 의존성 배열에 들어가는 값에 따라 `useEffect`가 언제 재실행되는지 결정되므로, 필요한 값만 의존성 배열에 넣도록 주의해야 합니다.

**3.3 `clean up`함수**

- 이벤트 핸들링처럼 `useEffect` 안에서 이벤트 리스너를 추가하는 경우, `clean-up` 함수를 제공해야 합니다. 기명함수를 사용하면 `clean-up` 함수도 명확하게 이름을 지어 관리할 수 있어 코드의 명확성을 높입니다.

### ⭐️ 요약

- `useEffect`에서 기명함수를 사용하면 에러 파악이 쉬워지고, 코드 가독성과 유지보수성이 향상됩니다.
- 기명함수는 로직의 의도를 명확히 하고, 디버깅 시에 로그에서 함수명을 통해 에러 위치를 쉽게 찾을 수 있습니다.
- `clean-up`도 명확하게 함수명으로 관리하면 코드 흐름을 쉽게 이해할 수 있습니다.

<br />
<br />

# ✅ 한 가지 역할만 수행하는 useEffect

---

### 🌈 결론

- `useEffect` 를 작성할 때, 한가지의 역할을 할 수 있도록 작성하자.

### ✍️ 내용

- SRP - 단일책임 원칙
  - 하나의 역할만 수행하는 무언가를 만들자 ⇒ `useEffect()`
  - 확인 하는 방법
    - 기명 함수를 작성해보자
    - Dependency Arrays가 너무 많은 관찰 대상이 들어가고 있는게 아닌지 확인

```tsx
function LoginPage({ token, newPath }) {
  // ❌ 위험
  useEffect(() => {
    redirect(newPath);

    const userInfo = setLogin(token);
    // ... 로그인 로직
  }, [token, newPath]);

  // ✅ 분리

  useEffect(() => {
    redirect(newPath);
  }, [newPath]);

  useEffect(() => {
    const userInfo = setLogin(token);
    // ... 로그인 로직

    if (options) {
      // 부가적인 로직 <= 추가 동작해도 이상이 없고 부작용이 생길 일이 업을 경우
    }
  }, [token, options]);
}
```

### ⭐️ 요약

- `useEffect` 를 사용할 때, 한 가지 역할만 할 수 있도록 작성하자.

# ✅ Custom Hook 반환의 종류

---

### 🌈 결론

- React에서 제공하는 컨벤션에 맞게 Custom Hook을 사용하자

### ✍️ 내용

1. Custom Hook 사용시 지켜야 할 규칙들

   ```tsx
   function ReturnCustomHooks() {
   	// ❌
   	const [setValue, value] = useSomeHooks(true);

   	// ✅
   	const [value, setValue] = useSomeHooks(true);


   	// ❌
   	const [oneValue] = useSomeHooks();

     // ✅
   	const oneValue = useSomeHooks();


   	// ❌
   	constt [firstValue, secondValue, _, thirdValue] = useSomeHooks(true);

     // ✅
     const { firstValue, secondValue, rest} = useSomeHooks(true)


   	// ❌
   	const query = useQuery({ queryKey: ['hello', queryFn: getHello })
   	const data = query.data;
   	const refetch = query.refetch;
   	const isSuccess = query.isSuccess

   	// ✅
     const { data, refetch, isSuccess } = useQuery({ queryKey: ['hello', queryFn: getHello })
   }
   ```

### ⭐️ 요약

- Custom Hook을 사용할 때, 일관된 컨벤션을 작성하자.

# ✅ useEffect 내부의 비동기 함수

---

### 🌈 결론

- `useEffect` 사용시 Promise 값을 리턴하는 비동기 함수 사용시 주의하자

### ✍️ 내용

1. `useEffect` 내부에서 비동기 함수 처리

   ```tsx
   // ❌
   // useEffect 리턴 값은 undefined이거나 clean function임
   useEffect(async () => {
     // 비동기 작업
     const result = await fetchData();
   }, []);

   // ✅
   useEffect(async () => {
     // 비동기 작업
     const fetchData = async () => {
       const result = await someFetch();
     };

     fetchData();
   }, []);
   ```

### ⭐️ 요약

- `useEffect` 내부에서 비동기 함수를 사용하는 것이 아닌, 커스텀 훅이나, 다른 곳에서 사용할 수 있도록 하자

<br />

### 참고

- [클린코드 리액트](https://www.udemy.com/course/clean-code-react/)
